===========================================LECTURE 09===========================================
================================================================================================

inline functions

some objects do not defy the ODR when defined in different header files iff they are defined same token-by-token, inline functions are one of these objects

###REMARK###
	inline functions and inlined functions are different things.
	inline keyword lets us define the function in the header file.
	inline keyword requests this function to be inlined by the compiler, but compiler does not have to comply. so inline keyword does not affect the inline expansion.
	inline keyword does not defile the ODR.
	defining a function in a header file requires the inclusion of other header files that contain the complete types.
	member functions are inline functions even if the keyword is not used.
###REMARK###

###REMARK###
	things that are in the header file but do not defile the ODR
		- inline functions
		- constexpr functions
		- class definitions
		- templates
			- function templates
			- class templates
			- alias templates
			- variable templates
###REMARK###

static keyword creates internal linkage

================================================================================================
constexpr keyword

const and constexpr are different from each other
	if a const variable defined with a constant expression(e.g. int x = 5, 5 here is the constant expression) than expression generated by the variable is constexpr
	if it's initialized with a variable expression than the expression generated by the variable is not constexpr
	e.g.
		const int x = 5;
		const int y = foo();	// foo is a function that returns int
		int arr1[x]{};			// is valid because here the expression x is constexpr
		int arr2[y]{};			// is invalid because here the expression y is not constexpr, and compiler has to know the size of the array at the compile time

constexpr keyword
	constexpr int x = 10;		// when constexpr used in declaration, we must use a constant expression to initialize the variable

###REMARK###
	expressions generated by variables defined with const keyword, may or may not generate a constant expression
	but
	expressions generated by varibles defined with constexpr keyword, always generate a constant expression
###REMARK###

	constexpr functions
	they exist mainly because efficiency reasons.

	for a function to be defined as constexpr function it must be;
		1-) it's return type
		2-) types of it's parameters
		3-) types of it's local variables
		
		all must be literal types. arithmetic types, pointer types are literal types. for a class to be a literal type there are conditions it must satisfy(topic for later).

================================================================================================
classes

	class definition
		//data members
		//member functions
		//type member / member type / nested type
		
	class members
		data members
			non-static data members
			static data members
		member functions
			non-static member function
			static member function
			
		type members

	classes have access control
		public
		private
		protected
name lookup
context control
access control

if a function is part of a class then it is called member function, if it belongs to the global scope then it's called global function or free function or stand-alone function.

class Myclass{
public:
	void foo();			// non-static member function
		non-static member functions have a hidden parameter. pointer of the class they belong to. for this example it is Myclass*, so void foo() is actually void foo(Myclass*);
	static void bar();	// static	  member function
private:
	int mx;				// non-static data member
	static int my;		// static	  data member
}