===========================================LECTURE 003===========================================
================================================================================================

===========basic types===========

bool
char
signed char
unsigned
--------------
short
unsigned short
--------------
int
unsigned int
--------------
long
unsigned long
--------------
long long
unsigned long long

sizeof(short) <= sizeof(int) <= sizeof(long) <= sizeof(long long)
--------------
float		(4 bytes)
double		(8 bytes)
long double

4.5 means double
4.5F means float

Types				Suffix
unsigned			U
long				L
float				F	(has to contain . , e.g. 34F is a syntax error, correct way is 34.F)
unsigned long		UL or LU
unsigned long long	ULL or LLU

##REMARK##
	-when signed or unsigned used without any type keywords like signed x or unsigned x, it automatically becomes signed int x or unsigned int x
	-using scientific notation in real numbers eliminates the necessity of . e.g. 10e2, 10e2F
	-if you exceed the value limits of int of float, variable type automatically changes to the respective bigger types, depending on which type can contain that value
	-to make reading large numbers easier, ' (digit separator) can be used, e.g. int x = 784'123; would mean int x = 784123; but it is much easier to read the number. this is not exclusive to decimals.
##REMARK##

----------------
C				C++
decimal			decimal		41		(default)
octal			octal		041
hexadecimal		hexadecimal	0x41
				binary		0b1001
---------------------------------------------

default type of variables are int

ival * 1000 int operation
ival * 1000L long operation (typecasting)

variable types are critically important for function overloading

C
scope: names have scope
e.g.
block scope
file scope
function prototype scope
function scope

C++
block scope
namespace scope
class scope
function prototype scope
function scope

name lookup


===========
expression

most widely used statement form

expression statement

x = 5;

every expression has;
data type
value category

priority operator does not change the value category. e.g. x = 9 and (((((((((x))))))))) = 9 are the same thing.

constexpr;		###REMARK### constant(const) and constant expression(constexpr) are different from each other
C definition: if the value of an expression is known by the compiler at the compile time that expression is a constant expression(constexpr)

in C there are some places that constexpr must be used;
e.g.
int a[constexpr] because compiler has to know the size of the array
initializations of global variables
case label expressions in switch
bitfield member

in C++ importance of constepxr is much more greater then in C



================================================================================================================================================
operators
	operand(s)
	unary
	binary
	ternary	(the ternary/conditional operator)

	prefix		*ptr or ++x or --x etc.
	postfix		x++ or x-- etc.
	infix		a + b or a * b etc.

------------------------------------------------------------------------------------------------------------------------------------------------
1	[ ] subscript(index operator)	( ) function call operator		.(dot operator) and ->(arrow operator) member selection operator
------------------------------------------------------------------------------------------------------------------------------------------------
2	++(increment operator)		--(decrement operator)		!(logical not operator)		~(bitwise not operator)		(type)(typecasting operator)
	&(address operator)			*(dereferencing operator)	sizeof						+(sign operator)			-(sign operator)

	###REMARK###
		sizeof		is a keyword and is an operator, not a function
		sizeof		is a compile time operator, which means expressions generated by sizeof are constexpr, which means it can be used in array declarations
		sizeof		type of expressions generated by sizeof is size_t(is an unsigned int)
		sizeof		usage of () is necessary only when using type name as its operand e.g.	sizeof(int), sizeof(double)
		sizeof		operand of sizeof operator is unevaluated context
------------------------------------------------------------------------------------------------------------------------------------------------
3	*(multiplication operator)	/(division operator)		%(modulus operator)
------------------------------------------------------------------------------------------------------------------------------------------------
4	+(addition operator)		-(subtraction operator)
------------------------------------------------------------------------------------------------------------------------------------------------
5	>>(bitwise right shift)		<<(bitwise left shift)
	
	###REMARK###
		right operand of bit shift operators must be smaller than the number of bits of its right operand, also must be a positive value
------------------------------------------------------------------------------------------------------------------------------------------------
6	>(greater than)				<(less than)				>=(greater than or equal to)			<=(less than or equal to)
------------------------------------------------------------------------------------------------------------------------------------------------
7	==							!=
------------------------------------------------------------------------------------------------------------------------------------------------
8	&(bitwise and)
------------------------------------------------------------------------------------------------------------------------------------------------
9	^(bitwise xor)
------------------------------------------------------------------------------------------------------------------------------------------------
10	|(bitwise or)
------------------------------------------------------------------------------------------------------------------------------------------------
11	&&(logical and)
------------------------------------------------------------------------------------------------------------------------------------------------
12	||(logical and)
------------------------------------------------------------------------------------------------------------------------------------------------
13	?:(ternary operator)
	e.g.
		assignment
			z = x > y ? a : b;
		function(a > b ? a : b)
		return statements
			return x > 10 ? x : b;

------------------------------------------------------------------------------------------------------------------------------------------------
14	=	+=	-=	*=	/=	%=	&=	^=	|=		(compound operators)
------------------------------------------------------------------------------------------------------------------------------------------------
15	,(comma operator)	is a binary operator that evaluates its first operand and discards the result, it then evaluates the second operand and returns this value (and type).
	
		int num1 = (5, 10);			//10 is assigned to num
		int num2 = (f1(), f2());	//f1() is called(evaluated) first followed by f2(). the returned value of f2() is assigned to num2
	###REMARK###
		separator comma and operator comma are different from each other
------------------------------------------------------------------------------------------------------------------------------------------------

short circuit behavior;
	&& if the left operand is false, right operand is not calculated
	|| if the left operand is true,  right operand is not calculated


yielded value	generated value		return value		are the same thing

postfix and prefix values have side effects, they change the value of their operand, e.g.
	int x = 10;
	int y = x++;		in this, y will be 10, and x will be increased to 11

	int x = 10;
	int y = ++x;		in this, y will be 11, and x will be increased to 11
				
				in both examples x has the value 11 because of the side effect but, in the first one it happens after the y is initialized

return value of every assignment operator is the value that is assigned to the variable



sequence point(also called sequencing in C++):		expressions causing a side effect before this point, must be completed after this point
	e.g.
		x = 10;
		x++;
		-------------sequence point
		x;		//x is 11 from here
	e.g. for sequence points
		int x = 5, y = ++x, z = y + x;		here comma separator creates a sequence point, therefore at the end of this line, x is 6, y is 6 and z is 12
		expression in if, switch, while, do-while and semicolons in for are sequence points
		left hand operand of && operator is a sequence point
order of evaluation


f1() + f2() * 5
	f1 will be evaluated first, then f2, then multiplication and finally addition


token
e.g.
	identifier
	operator
	string literal e.g. "mike"
	keywords